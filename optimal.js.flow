declare module 'optimal' {
  declare export type SupportedType =
    'array' | 'boolean' | 'function' | 'instance' | 'number' |
    'object' | 'shape' | 'string' | 'union' | 'custom';

  declare export type Checker = (path: string, value: *, ...args: *[]) => void;

  declare export type CustomCallback = (value: *, options: Object) => void;

  declare export type Blueprint = { [key: string]: Builder<*> | Blueprint };

  declare export type Config = {
    name?: string,
    unknown?: boolean,
  };

  declare export class Builder<T> {
    checks: {
      args: *[],
      func: Checker,
    }[];
    currentConfig: Config;
    currentOptions: Object;
    defaultValue: T;
    deprecatedMessage: string;
    errorMessage: string;
    isNullable: boolean;
    isRequired: boolean;
    type: SupportedType;
    constructor(type: SupportedType, defaultValue: T): void;
    addCheck(func: Checker, ...args: *[]): this;
    and(...keys: string[]): this;
    custom(callback: CustomCallback): this;
    deprecate(message: string): this;
    invariant(condition: boolean, message: string, path?: string): void;
    key(path: string): string;
    message(message: string): this;
    nullable(state?: boolean): this;
    only(): this;
    or(...keys: string[]): this;
    required(state?: boolean): this;
    runChecks(path: string, value: *, options: Object, config?: Config): *;
    typeAlias(): string;
    xor(...keys: string[]): this;
  }

  declare export class CollectionBuilder<T, TDefault> extends Builder<?TDefault> {
    contents: ?Builder<T>;
    constructor(type: 'array' | 'object', contents?: ?Builder<T>, defaultValue?: ?TDefault): void;
    notEmpty(): this;
  }

  declare export class InstanceBuilder<T: Function> extends Builder<?T> {
    refClass: ?T;
    constructor(refClass?: ?T): void;
  }

  declare export class NumberBuilder<T: number> extends Builder<?T> {
    constructor(defaultValue?: ?T): void;
    between(min: number, max: number, inclusive?: boolean): this;
    gt(min: number, inclusive?: boolean): this;
    gte(min: number): this;
    lt(max: number, inclusive?: boolean): this;
    lte(max: number): this;
    oneOf(list: T[]): this;
  }

  declare export class ShapeBuilder extends Builder<?{ [key: string]: * }> {
    constructor(
      contents: { [key: string]: Builder<*> },
      defaultValue?: ?{ [key: string]: * },
    ): void;
  }

  declare export class StringBuilder<T: string> extends Builder<?T> {
    allowEmpty: boolean;
    constructor(defaultValue?: ?T): void;
    contains(token: string, index?: number): this;
    match(pattern: RegExp): this;
    empty(): this;
    oneOf(list: T[]): this;
  }

  declare export class UnionBuilder extends Builder<*> {
    builders: Builder<*>[];
    constructor(builders: Builder<*>[], defaultValue?: *): void;
  }

  declare export function array(
    builder: Builder<*>,
    defaultValue?: ?*[],
  ): CollectionBuilder<*, *[]>;

  declare export function bool<T: boolean>(defaultValue?: ?T): Builder<?T>;

  declare export function custom(callback: CustomCallback, defaultValue?: *): Builder<*>;

  declare export function date(): InstanceBuilder<Class<Date>>;

  declare export function func<T: Function>(defaultValue?: ?T): Builder<?T>;

  declare export function instance(refClass: *): InstanceBuilder<*>;

  declare export function number<T: number>(defaultValue?: ?T): NumberBuilder<T>;

  declare export function object(
    builder?: Builder<*>,
    defaultValue?: ?{ [key: string]: * },
  ): CollectionBuilder<*, { [key: string]: * }>;

  declare export function regex(): InstanceBuilder<Class<RegExp>>;

  declare export function shape(builders: { [key: string]: Builder<*> }, defaultValue?: ?{ [key: string]: * }): ShapeBuilder;

  declare export function string<T: string>(defaultValue?: ?T): StringBuilder<T>;

  declare export function union(builders: Builder<*>[], defaultValue?: *): UnionBuilder;

  declare export default function Options(
    options: Object,
    blueprint: Blueprint,
    config?: Config,
  ): Object;
}
